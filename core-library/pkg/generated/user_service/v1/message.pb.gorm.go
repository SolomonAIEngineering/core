package user_servicev1

import (
	context "context"
	fmt "fmt"
	strings "strings"
	time "time"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type TeamORM struct {
	CreatedAt              *time.Time
	Description            string
	Id                     uint64                `gorm:"unique_index:idx_team_id"`
	MemberBusinessAccounts []*BusinessAccountORM `gorm:"foreignkey:MemberBusinessAccountsTeamId;association_foreignkey:Id;preload:true"`
	MemberUsersAccounts    []*UserAccountORM     `gorm:"foreignkey:TeamId;association_foreignkey:Id;preload:true"`
	Name                   string
	RoleId                 *int64
	Roles                  []*RoleORM          `gorm:"foreignkey:TeamId;association_foreignkey:Id;preload:true"`
	Tags                   []*TagsORM          `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	TeamAdmin              *BusinessAccountORM `gorm:"foreignkey:TeamAdminTeamId;association_foreignkey:Id;preload:true"`
	UpdatedAt              *time.Time
}

// TableName overrides the default tablename generated by GORM
func (TeamORM) TableName() string {
	return "teams"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Team) ToORM(ctx context.Context) (TeamORM, error) {
	to := TeamORM{}
	var err error
	if prehook, ok := interface{}(m).(TeamWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if m.TeamAdmin != nil {
		tempTeamAdmin, err := m.TeamAdmin.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TeamAdmin = &tempTeamAdmin
	}
	for _, v := range m.MemberUsersAccounts {
		if v != nil {
			if tempMemberUsersAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.MemberUsersAccounts = append(to.MemberUsersAccounts, &tempMemberUsersAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.MemberUsersAccounts = append(to.MemberUsersAccounts, nil)
		}
	}
	for _, v := range m.MemberBusinessAccounts {
		if v != nil {
			if tempMemberBusinessAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.MemberBusinessAccounts = append(to.MemberBusinessAccounts, &tempMemberBusinessAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.MemberBusinessAccounts = append(to.MemberBusinessAccounts, nil)
		}
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	for _, v := range m.Roles {
		if v != nil {
			if tempRoles, cErr := v.ToORM(ctx); cErr == nil {
				to.Roles = append(to.Roles, &tempRoles)
			} else {
				return to, cErr
			}
		} else {
			to.Roles = append(to.Roles, nil)
		}
	}
	if posthook, ok := interface{}(m).(TeamWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TeamORM) ToPB(ctx context.Context) (Team, error) {
	to := Team{}
	var err error
	if prehook, ok := interface{}(m).(TeamWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if m.TeamAdmin != nil {
		tempTeamAdmin, err := m.TeamAdmin.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TeamAdmin = &tempTeamAdmin
	}
	for _, v := range m.MemberUsersAccounts {
		if v != nil {
			if tempMemberUsersAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.MemberUsersAccounts = append(to.MemberUsersAccounts, &tempMemberUsersAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.MemberUsersAccounts = append(to.MemberUsersAccounts, nil)
		}
	}
	for _, v := range m.MemberBusinessAccounts {
		if v != nil {
			if tempMemberBusinessAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.MemberBusinessAccounts = append(to.MemberBusinessAccounts, &tempMemberBusinessAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.MemberBusinessAccounts = append(to.MemberBusinessAccounts, nil)
		}
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	for _, v := range m.Roles {
		if v != nil {
			if tempRoles, cErr := v.ToPB(ctx); cErr == nil {
				to.Roles = append(to.Roles, &tempRoles)
			} else {
				return to, cErr
			}
		} else {
			to.Roles = append(to.Roles, nil)
		}
	}
	if posthook, ok := interface{}(m).(TeamWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Team the arg will be the target, the caller the one being converted from

// TeamBeforeToORM called before default ToORM code
type TeamWithBeforeToORM interface {
	BeforeToORM(context.Context, *TeamORM) error
}

// TeamAfterToORM called after default ToORM code
type TeamWithAfterToORM interface {
	AfterToORM(context.Context, *TeamORM) error
}

// TeamBeforeToPB called before default ToPB code
type TeamWithBeforeToPB interface {
	BeforeToPB(context.Context, *Team) error
}

// TeamAfterToPB called after default ToPB code
type TeamWithAfterToPB interface {
	AfterToPB(context.Context, *Team) error
}

type UserAccountORM struct {
	AccountType     string
	Address         *AddressORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id"`
	AlgoliaUserId   string
	Auth0UserId     string `gorm:"unique_index:idx_user_auth0_user_id"`
	AuthnAccountId  uint64
	Bio             string
	CreatedAt       *time.Time
	Email           string `gorm:"unique_index:idx_user_email"`
	Firstname       string
	Headline        string
	Id              uint64 `gorm:"unique_index:idx_user_id"`
	IsActive        bool
	IsEmailVerified bool
	IsPrivate       bool
	Lastname        string
	PhoneNumber     string
	ProfileImageUrl string
	RoleId          *int64
	Settings        *SettingsORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id"`
	Tags            []*TagsORM   `gorm:"foreignkey:UserAccountId;association_foreignkey:Id"`
	TeamId          *uint64
	Username        string `gorm:"unique_index:idx_user_username"`
	VerifiedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (UserAccountORM) TableName() string {
	return "user_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserAccount) ToORM(ctx context.Context) (UserAccountORM, error) {
	to := UserAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(UserAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.VerifiedAt != nil {
		t := m.VerifiedAt.AsTime()
		to.VerifiedAt = &t
	}
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	to.AccountType = ProfileType_name[int32(m.AccountType)]
	to.ProfileImageUrl = m.ProfileImageUrl
	to.Auth0UserId = m.Auth0UserId
	to.AlgoliaUserId = m.AlgoliaUserId
	if posthook, ok := interface{}(m).(UserAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserAccountORM) ToPB(ctx context.Context) (UserAccount, error) {
	to := UserAccount{}
	var err error
	if prehook, ok := interface{}(m).(UserAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.VerifiedAt != nil {
		to.VerifiedAt = timestamppb.New(*m.VerifiedAt)
	}
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	to.AccountType = ProfileType(ProfileType_value[m.AccountType])
	to.ProfileImageUrl = m.ProfileImageUrl
	to.Auth0UserId = m.Auth0UserId
	to.AlgoliaUserId = m.AlgoliaUserId
	if posthook, ok := interface{}(m).(UserAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserAccount the arg will be the target, the caller the one being converted from

// UserAccountBeforeToORM called before default ToORM code
type UserAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserAccountORM) error
}

// UserAccountAfterToORM called after default ToORM code
type UserAccountWithAfterToORM interface {
	AfterToORM(context.Context, *UserAccountORM) error
}

// UserAccountBeforeToPB called before default ToPB code
type UserAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserAccount) error
}

// UserAccountAfterToPB called after default ToPB code
type UserAccountWithAfterToPB interface {
	AfterToPB(context.Context, *UserAccount) error
}

type BusinessAccountORM struct {
	AccountType                  string
	Address                      *AddressORM `gorm:"foreignkey:BusinessAccountId;association_foreignkey:Id;preload:true"`
	AlgoliaUserId                string
	Auth0UserId                  string `gorm:"unique_index:auth0_user_id"`
	AuthnAccountId               uint64
	Bio                          string
	CompanyDescription           string
	CompanyEstablishedDate       string
	CompanyIndustryType          string
	CompanyName                  string
	CompanyWebsiteUrl            string
	CreatedAt                    *time.Time
	Email                        string `gorm:"unique_index:idx_business_email"`
	Headline                     string
	Id                           uint64 `gorm:"unique_index:idx_business_id"`
	IsActive                     bool
	IsEmailVerified              bool
	IsPrivate                    bool
	MemberBusinessAccountsTeamId *uint64
	PhoneNumber                  string
	ProfileImageUrl              string
	RoleId                       *int64
	Settings                     *SettingsORM `gorm:"foreignkey:BusinessAccountId;association_foreignkey:Id;preload:true"`
	Tags                         []*TagsORM   `gorm:"foreignkey:BusinessAccountId;association_foreignkey:Id;preload:true"`
	TeamAdminTeamId              *uint64
	Username                     string `gorm:"unique_index:idx_business_username"`
	VerifiedAt                   *time.Time
}

// TableName overrides the default tablename generated by GORM
func (BusinessAccountORM) TableName() string {
	return "business_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessAccount) ToORM(ctx context.Context) (BusinessAccountORM, error) {
	to := BusinessAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.VerifiedAt != nil {
		t := m.VerifiedAt.AsTime()
		to.VerifiedAt = &t
	}
	to.CompanyEstablishedDate = m.CompanyEstablishedDate
	to.CompanyIndustryType = m.CompanyIndustryType
	to.CompanyWebsiteUrl = m.CompanyWebsiteUrl
	to.CompanyDescription = m.CompanyDescription
	to.CompanyName = m.CompanyName
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	to.AccountType = ProfileType_name[int32(m.AccountType)]
	to.ProfileImageUrl = m.ProfileImageUrl
	to.Auth0UserId = m.Auth0UserId
	to.AlgoliaUserId = m.AlgoliaUserId
	if posthook, ok := interface{}(m).(BusinessAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessAccountORM) ToPB(ctx context.Context) (BusinessAccount, error) {
	to := BusinessAccount{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.VerifiedAt != nil {
		to.VerifiedAt = timestamppb.New(*m.VerifiedAt)
	}
	to.CompanyEstablishedDate = m.CompanyEstablishedDate
	to.CompanyIndustryType = m.CompanyIndustryType
	to.CompanyWebsiteUrl = m.CompanyWebsiteUrl
	to.CompanyDescription = m.CompanyDescription
	to.CompanyName = m.CompanyName
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	to.AccountType = ProfileType(ProfileType_value[m.AccountType])
	to.ProfileImageUrl = m.ProfileImageUrl
	to.Auth0UserId = m.Auth0UserId
	to.AlgoliaUserId = m.AlgoliaUserId
	if posthook, ok := interface{}(m).(BusinessAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessAccount the arg will be the target, the caller the one being converted from

// BusinessAccountBeforeToORM called before default ToORM code
type BusinessAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessAccountORM) error
}

// BusinessAccountAfterToORM called after default ToORM code
type BusinessAccountWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessAccountORM) error
}

// BusinessAccountBeforeToPB called before default ToPB code
type BusinessAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessAccount) error
}

// BusinessAccountAfterToPB called after default ToPB code
type BusinessAccountWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessAccount) error
}

type AddressORM struct {
	Address           string
	BusinessAccountId *uint64
	City              string
	Id                uint64 `gorm:"unique_index:idx_address_id"`
	Lattitude         string
	Longitude         string
	State             string
	Unit              string
	UserAccountId     *uint64
	Zipcode           string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.Zipcode = m.Zipcode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.Zipcode = m.Zipcode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type TagsORM struct {
	BusinessAccountId *uint64
	Id                uint64         `gorm:"unique_index:idx_tags_id"`
	Metadata          pq.StringArray `gorm:"type:text[]"`
	TagDescription    string
	TagName           string
	TeamId            *uint64
	UserAccountId     *uint64
}

// TableName overrides the default tablename generated by GORM
func (TagsORM) TableName() string {
	return "tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tags) ToORM(ctx context.Context) (TagsORM, error) {
	to := TagsORM{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TagsORM) ToPB(ctx context.Context) (Tags, error) {
	to := Tags{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tags the arg will be the target, the caller the one being converted from

// TagsBeforeToORM called before default ToORM code
type TagsWithBeforeToORM interface {
	BeforeToORM(context.Context, *TagsORM) error
}

// TagsAfterToORM called after default ToORM code
type TagsWithAfterToORM interface {
	AfterToORM(context.Context, *TagsORM) error
}

// TagsBeforeToPB called before default ToPB code
type TagsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tags) error
}

// TagsAfterToPB called after default ToPB code
type TagsWithAfterToPB interface {
	AfterToPB(context.Context, *Tags) error
}

type RoleORM struct {
	AuditLog          []*RoleAuditEventsORM `gorm:"foreignkey:RoleId;association_foreignkey:Id;preload:true"`
	Business          *BusinessAccountORM   `gorm:"foreignkey:RoleId;association_foreignkey:Id;preload:true"`
	CanCreateProjects bool
	CanCreateReports  bool
	CanCreateUsers    bool
	CanDeleteProjects bool
	CanDeleteReports  bool
	CanDeleteUsers    bool
	CanReadProjects   bool
	CanReadReports    bool
	CanReadUsers      bool
	CanUpdateProjects bool
	CanUpdateReports  bool
	CanUpdateUsers    bool
	CreatedAt         *time.Time
	Id                int64    `gorm:"unique_index:idx_role_id"`
	Name              string   `gorm:"unique_index:idx_role_name"`
	Team              *TeamORM `gorm:"foreignkey:RoleId;association_foreignkey:Id;preload:true"`
	TeamId            *uint64
	Type              string
	UpdatedAt         *time.Time
	User              *UserAccountORM `gorm:"foreignkey:RoleId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (RoleORM) TableName() string {
	return "roles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Role) ToORM(ctx context.Context) (RoleORM, error) {
	to := RoleORM{}
	var err error
	if prehook, ok := interface{}(m).(RoleWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Type = RoleType_name[int32(m.Type)]
	to.CanCreateUsers = m.CanCreateUsers
	to.CanReadUsers = m.CanReadUsers
	to.CanUpdateUsers = m.CanUpdateUsers
	to.CanDeleteUsers = m.CanDeleteUsers
	to.CanCreateProjects = m.CanCreateProjects
	to.CanReadProjects = m.CanReadProjects
	to.CanUpdateProjects = m.CanUpdateProjects
	to.CanDeleteProjects = m.CanDeleteProjects
	to.CanCreateReports = m.CanCreateReports
	to.CanReadReports = m.CanReadReports
	to.CanUpdateReports = m.CanUpdateReports
	to.CanDeleteReports = m.CanDeleteReports
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	for _, v := range m.AuditLog {
		if v != nil {
			if tempAuditLog, cErr := v.ToORM(ctx); cErr == nil {
				to.AuditLog = append(to.AuditLog, &tempAuditLog)
			} else {
				return to, cErr
			}
		} else {
			to.AuditLog = append(to.AuditLog, nil)
		}
	}
	if m.Team != nil {
		tempTeam, err := m.Team.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Team = &tempTeam
	}
	if m.User != nil {
		tempUser, err := m.User.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	if m.Business != nil {
		tempBusiness, err := m.Business.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Business = &tempBusiness
	}
	if posthook, ok := interface{}(m).(RoleWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *RoleORM) ToPB(ctx context.Context) (Role, error) {
	to := Role{}
	var err error
	if prehook, ok := interface{}(m).(RoleWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Type = RoleType(RoleType_value[m.Type])
	to.CanCreateUsers = m.CanCreateUsers
	to.CanReadUsers = m.CanReadUsers
	to.CanUpdateUsers = m.CanUpdateUsers
	to.CanDeleteUsers = m.CanDeleteUsers
	to.CanCreateProjects = m.CanCreateProjects
	to.CanReadProjects = m.CanReadProjects
	to.CanUpdateProjects = m.CanUpdateProjects
	to.CanDeleteProjects = m.CanDeleteProjects
	to.CanCreateReports = m.CanCreateReports
	to.CanReadReports = m.CanReadReports
	to.CanUpdateReports = m.CanUpdateReports
	to.CanDeleteReports = m.CanDeleteReports
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	for _, v := range m.AuditLog {
		if v != nil {
			if tempAuditLog, cErr := v.ToPB(ctx); cErr == nil {
				to.AuditLog = append(to.AuditLog, &tempAuditLog)
			} else {
				return to, cErr
			}
		} else {
			to.AuditLog = append(to.AuditLog, nil)
		}
	}
	if m.Team != nil {
		tempTeam, err := m.Team.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Team = &tempTeam
	}
	if m.User != nil {
		tempUser, err := m.User.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	if m.Business != nil {
		tempBusiness, err := m.Business.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Business = &tempBusiness
	}
	if posthook, ok := interface{}(m).(RoleWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Role the arg will be the target, the caller the one being converted from

// RoleBeforeToORM called before default ToORM code
type RoleWithBeforeToORM interface {
	BeforeToORM(context.Context, *RoleORM) error
}

// RoleAfterToORM called after default ToORM code
type RoleWithAfterToORM interface {
	AfterToORM(context.Context, *RoleORM) error
}

// RoleBeforeToPB called before default ToPB code
type RoleWithBeforeToPB interface {
	BeforeToPB(context.Context, *Role) error
}

// RoleAfterToPB called after default ToPB code
type RoleWithAfterToPB interface {
	AfterToPB(context.Context, *Role) error
}

type RoleAuditEventsORM struct {
	Action         string         `gorm:"index:idx_role_audit_events_action"`
	AffectedFields pq.StringArray `gorm:"type:text[]"`
	ClientIp       string
	Context        string
	Id             int64          `gorm:"unique_index:idx_role_audit_events_id"`
	PerformedBy    string         `gorm:"index:idx_role_audit_events_performed_by"`
	PreviousValues pq.StringArray `gorm:"type:text[]"`
	RoleId         *int64
	Timestamp      *time.Time `gorm:"index:idx_role_audit_events_timestamp"`
	UserAgent      string
}

// TableName overrides the default tablename generated by GORM
func (RoleAuditEventsORM) TableName() string {
	return "role_audit_events"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *RoleAuditEvents) ToORM(ctx context.Context) (RoleAuditEventsORM, error) {
	to := RoleAuditEventsORM{}
	var err error
	if prehook, ok := interface{}(m).(RoleAuditEventsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Action = AuditAction_name[int32(m.Action)]
	to.PerformedBy = m.PerformedBy
	if m.Timestamp != nil {
		t := m.Timestamp.AsTime()
		to.Timestamp = &t
	}
	if m.AffectedFields != nil {
		to.AffectedFields = make(pq.StringArray, len(m.AffectedFields))
		copy(to.AffectedFields, m.AffectedFields)
	}
	if m.PreviousValues != nil {
		to.PreviousValues = make(pq.StringArray, len(m.PreviousValues))
		copy(to.PreviousValues, m.PreviousValues)
	}
	to.ClientIp = m.ClientIp
	to.UserAgent = m.UserAgent
	to.Context = m.Context
	if posthook, ok := interface{}(m).(RoleAuditEventsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *RoleAuditEventsORM) ToPB(ctx context.Context) (RoleAuditEvents, error) {
	to := RoleAuditEvents{}
	var err error
	if prehook, ok := interface{}(m).(RoleAuditEventsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Action = AuditAction(AuditAction_value[m.Action])
	to.PerformedBy = m.PerformedBy
	if m.Timestamp != nil {
		to.Timestamp = timestamppb.New(*m.Timestamp)
	}
	if m.AffectedFields != nil {
		to.AffectedFields = make(pq.StringArray, len(m.AffectedFields))
		copy(to.AffectedFields, m.AffectedFields)
	}
	if m.PreviousValues != nil {
		to.PreviousValues = make(pq.StringArray, len(m.PreviousValues))
		copy(to.PreviousValues, m.PreviousValues)
	}
	to.ClientIp = m.ClientIp
	to.UserAgent = m.UserAgent
	to.Context = m.Context
	if posthook, ok := interface{}(m).(RoleAuditEventsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type RoleAuditEvents the arg will be the target, the caller the one being converted from

// RoleAuditEventsBeforeToORM called before default ToORM code
type RoleAuditEventsWithBeforeToORM interface {
	BeforeToORM(context.Context, *RoleAuditEventsORM) error
}

// RoleAuditEventsAfterToORM called after default ToORM code
type RoleAuditEventsWithAfterToORM interface {
	AfterToORM(context.Context, *RoleAuditEventsORM) error
}

// RoleAuditEventsBeforeToPB called before default ToPB code
type RoleAuditEventsWithBeforeToPB interface {
	BeforeToPB(context.Context, *RoleAuditEvents) error
}

// RoleAuditEventsAfterToPB called after default ToPB code
type RoleAuditEventsWithAfterToPB interface {
	AfterToPB(context.Context, *RoleAuditEvents) error
}

// DefaultCreateTeam executes a basic gorm create call
func DefaultCreateTeam(ctx context.Context, in *Team, db *gorm.DB) (*Team, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TeamORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TeamORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTeam(ctx context.Context, in *Team, db *gorm.DB) (*Team, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TeamORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TeamORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TeamORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TeamORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TeamORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TeamORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTeam(ctx context.Context, in *Team, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TeamORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TeamORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TeamORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTeamSet(ctx context.Context, in []*Team, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TeamORM{})).(TeamORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TeamORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TeamORM{})).(TeamORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TeamORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Team, *gorm.DB) (*gorm.DB, error)
}
type TeamORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Team, *gorm.DB) error
}

// DefaultStrictUpdateTeam clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTeam(ctx context.Context, in *Team, db *gorm.DB) (*Team, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTeam")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TeamORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterMemberBusinessAccounts := BusinessAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMemberBusinessAccounts.MemberBusinessAccountsTeamId = new(uint64)
	*filterMemberBusinessAccounts.MemberBusinessAccountsTeamId = ormObj.Id
	if err = db.Where(filterMemberBusinessAccounts).Delete(BusinessAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterMemberUsersAccounts := UserAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMemberUsersAccounts.TeamId = new(uint64)
	*filterMemberUsersAccounts.TeamId = ormObj.Id
	if err = db.Where(filterMemberUsersAccounts).Delete(UserAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterRoles := RoleORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRoles.TeamId = new(uint64)
	*filterRoles.TeamId = ormObj.Id
	if err = db.Where(filterRoles).Delete(RoleORM{}).Error; err != nil {
		return nil, err
	}
	filterTags := TagsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTags.TeamId = new(uint64)
	*filterTags.TeamId = ormObj.Id
	if err = db.Where(filterTags).Delete(TagsORM{}).Error; err != nil {
		return nil, err
	}
	filterTeamAdmin := BusinessAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTeamAdmin.TeamAdminTeamId = new(uint64)
	*filterTeamAdmin.TeamAdminTeamId = ormObj.Id
	if err = db.Where(filterTeamAdmin).Delete(BusinessAccountORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TeamORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TeamORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TeamORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTeam executes a basic gorm update call with patch behavior
func DefaultPatchTeam(ctx context.Context, in *Team, updateMask *field_mask.FieldMask, db *gorm.DB) (*Team, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Team
	var err error
	if hook, ok := interface{}(&pbObj).(TeamWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTeam(ctx, &Team{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TeamWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTeam(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TeamWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTeam(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TeamWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TeamWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Team, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TeamWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Team, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TeamWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Team, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TeamWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Team, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTeam executes a bulk gorm update call with patch behavior
func DefaultPatchSetTeam(ctx context.Context, objects []*Team, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Team, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Team, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTeam(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTeam patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTeam(ctx context.Context, patchee *Team, patcher *Team, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Team, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTeamAdmin bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if !updatedTeamAdmin && strings.HasPrefix(f, prefix+"TeamAdmin.") {
			updatedTeamAdmin = true
			if patcher.TeamAdmin == nil {
				patchee.TeamAdmin = nil
				continue
			}
			if patchee.TeamAdmin == nil {
				patchee.TeamAdmin = &BusinessAccount{}
			}
			if o, err := DefaultApplyFieldMaskBusinessAccount(ctx, patchee.TeamAdmin, patcher.TeamAdmin, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TeamAdmin.", db); err != nil {
				return nil, err
			} else {
				patchee.TeamAdmin = o
			}
			continue
		}
		if f == prefix+"TeamAdmin" {
			updatedTeamAdmin = true
			patchee.TeamAdmin = patcher.TeamAdmin
			continue
		}
		if f == prefix+"MemberUsersAccounts" {
			patchee.MemberUsersAccounts = patcher.MemberUsersAccounts
			continue
		}
		if f == prefix+"MemberBusinessAccounts" {
			patchee.MemberBusinessAccounts = patcher.MemberBusinessAccounts
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Roles" {
			patchee.Roles = patcher.Roles
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTeam executes a gorm list call
func DefaultListTeam(ctx context.Context, db *gorm.DB) ([]*Team, error) {
	in := Team{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TeamORM{}, &Team{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TeamORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Team{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TeamORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TeamORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TeamORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TeamORM) error
}

// DefaultCreateUserAccount executes a basic gorm create call
func DefaultCreateUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserAccountSet(ctx context.Context, in []*UserAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserAccountORM{})).(UserAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserAccountORM{})).(UserAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserAccount, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserAccount, *gorm.DB) error
}

// DefaultStrictUpdateUserAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddress.UserAccountId = new(uint64)
	*filterAddress.UserAccountId = ormObj.Id
	if err = db.Where(filterAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterSettings := SettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSettings.UserAccountId = new(uint64)
	*filterSettings.UserAccountId = ormObj.Id
	if err = db.Where(filterSettings).Delete(SettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterTags := TagsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTags.UserAccountId = new(uint64)
	*filterTags.UserAccountId = ormObj.Id
	if err = db.Where(filterTags).Delete(TagsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserAccount executes a basic gorm update call with patch behavior
func DefaultPatchUserAccount(ctx context.Context, in *UserAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserAccount
	var err error
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserAccount(ctx, &UserAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserAccount(ctx context.Context, objects []*UserAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserAccount(ctx context.Context, patchee *UserAccount, patcher *UserAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAddress bool
	var updatedCreatedAt bool
	var updatedVerifiedAt bool
	var updatedSettings bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if !updatedAddress && strings.HasPrefix(f, prefix+"Address.") {
			updatedAddress = true
			if patcher.Address == nil {
				patchee.Address = nil
				continue
			}
			if patchee.Address == nil {
				patchee.Address = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Address, patcher.Address, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Address.", db); err != nil {
				return nil, err
			} else {
				patchee.Address = o
			}
			continue
		}
		if f == prefix+"Address" {
			updatedAddress = true
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"Headline" {
			patchee.Headline = patcher.Headline
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"AuthnAccountId" {
			patchee.AuthnAccountId = patcher.AuthnAccountId
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Firstname" {
			patchee.Firstname = patcher.Firstname
			continue
		}
		if f == prefix+"Lastname" {
			patchee.Lastname = patcher.Lastname
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"IsPrivate" {
			patchee.IsPrivate = patcher.IsPrivate
			continue
		}
		if f == prefix+"IsEmailVerified" {
			patchee.IsEmailVerified = patcher.IsEmailVerified
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedVerifiedAt && strings.HasPrefix(f, prefix+"VerifiedAt.") {
			if patcher.VerifiedAt == nil {
				patchee.VerifiedAt = nil
				continue
			}
			if patchee.VerifiedAt == nil {
				patchee.VerifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"VerifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.VerifiedAt, patchee.VerifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"VerifiedAt" {
			updatedVerifiedAt = true
			patchee.VerifiedAt = patcher.VerifiedAt
			continue
		}
		if !updatedSettings && strings.HasPrefix(f, prefix+"Settings.") {
			updatedSettings = true
			if patcher.Settings == nil {
				patchee.Settings = nil
				continue
			}
			if patchee.Settings == nil {
				patchee.Settings = &Settings{}
			}
			if o, err := DefaultApplyFieldMaskSettings(ctx, patchee.Settings, patcher.Settings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Settings.", db); err != nil {
				return nil, err
			} else {
				patchee.Settings = o
			}
			continue
		}
		if f == prefix+"Settings" {
			updatedSettings = true
			patchee.Settings = patcher.Settings
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"ProfileImageUrl" {
			patchee.ProfileImageUrl = patcher.ProfileImageUrl
			continue
		}
		if f == prefix+"Auth0UserId" {
			patchee.Auth0UserId = patcher.Auth0UserId
			continue
		}
		if f == prefix+"AlgoliaUserId" {
			patchee.AlgoliaUserId = patcher.AlgoliaUserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserAccount executes a gorm list call
func DefaultListUserAccount(ctx context.Context, db *gorm.DB) ([]*UserAccount, error) {
	in := UserAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserAccountORM{}, &UserAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserAccountORM) error
}

// DefaultCreateBusinessAccount executes a basic gorm create call
func DefaultCreateBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccountSet(ctx context.Context, in []*BusinessAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessAccountORM{})).(BusinessAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessAccountORM{})).(BusinessAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessAccount, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessAccount, *gorm.DB) error
}

// DefaultStrictUpdateBusinessAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddress.BusinessAccountId = new(uint64)
	*filterAddress.BusinessAccountId = ormObj.Id
	if err = db.Where(filterAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterSettings := SettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSettings.BusinessAccountId = new(uint64)
	*filterSettings.BusinessAccountId = ormObj.Id
	if err = db.Where(filterSettings).Delete(SettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterTags := TagsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTags.BusinessAccountId = new(uint64)
	*filterTags.BusinessAccountId = ormObj.Id
	if err = db.Where(filterTags).Delete(TagsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessAccount executes a basic gorm update call with patch behavior
func DefaultPatchBusinessAccount(ctx context.Context, in *BusinessAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessAccount
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessAccount(ctx, &BusinessAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessAccount(ctx context.Context, objects []*BusinessAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessAccount(ctx context.Context, patchee *BusinessAccount, patcher *BusinessAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAddress bool
	var updatedCreatedAt bool
	var updatedVerifiedAt bool
	var updatedSettings bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if !updatedAddress && strings.HasPrefix(f, prefix+"Address.") {
			updatedAddress = true
			if patcher.Address == nil {
				patchee.Address = nil
				continue
			}
			if patchee.Address == nil {
				patchee.Address = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Address, patcher.Address, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Address.", db); err != nil {
				return nil, err
			} else {
				patchee.Address = o
			}
			continue
		}
		if f == prefix+"Address" {
			updatedAddress = true
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"Headline" {
			patchee.Headline = patcher.Headline
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"AuthnAccountId" {
			patchee.AuthnAccountId = patcher.AuthnAccountId
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"IsPrivate" {
			patchee.IsPrivate = patcher.IsPrivate
			continue
		}
		if f == prefix+"IsEmailVerified" {
			patchee.IsEmailVerified = patcher.IsEmailVerified
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedVerifiedAt && strings.HasPrefix(f, prefix+"VerifiedAt.") {
			if patcher.VerifiedAt == nil {
				patchee.VerifiedAt = nil
				continue
			}
			if patchee.VerifiedAt == nil {
				patchee.VerifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"VerifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.VerifiedAt, patchee.VerifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"VerifiedAt" {
			updatedVerifiedAt = true
			patchee.VerifiedAt = patcher.VerifiedAt
			continue
		}
		if f == prefix+"CompanyEstablishedDate" {
			patchee.CompanyEstablishedDate = patcher.CompanyEstablishedDate
			continue
		}
		if f == prefix+"CompanyIndustryType" {
			patchee.CompanyIndustryType = patcher.CompanyIndustryType
			continue
		}
		if f == prefix+"CompanyWebsiteUrl" {
			patchee.CompanyWebsiteUrl = patcher.CompanyWebsiteUrl
			continue
		}
		if f == prefix+"CompanyDescription" {
			patchee.CompanyDescription = patcher.CompanyDescription
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if !updatedSettings && strings.HasPrefix(f, prefix+"Settings.") {
			updatedSettings = true
			if patcher.Settings == nil {
				patchee.Settings = nil
				continue
			}
			if patchee.Settings == nil {
				patchee.Settings = &Settings{}
			}
			if o, err := DefaultApplyFieldMaskSettings(ctx, patchee.Settings, patcher.Settings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Settings.", db); err != nil {
				return nil, err
			} else {
				patchee.Settings = o
			}
			continue
		}
		if f == prefix+"Settings" {
			updatedSettings = true
			patchee.Settings = patcher.Settings
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"ProfileImageUrl" {
			patchee.ProfileImageUrl = patcher.ProfileImageUrl
			continue
		}
		if f == prefix+"Auth0UserId" {
			patchee.Auth0UserId = patcher.Auth0UserId
			continue
		}
		if f == prefix+"AlgoliaUserId" {
			patchee.AlgoliaUserId = patcher.AlgoliaUserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessAccount executes a gorm list call
func DefaultListBusinessAccount(ctx context.Context, db *gorm.DB) ([]*BusinessAccount, error) {
	in := BusinessAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessAccountORM{}, &BusinessAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessAccountORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm.DB) error
}

// DefaultStrictUpdateAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask.FieldMask, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Unit" {
			patchee.Unit = patcher.Unit
			continue
		}
		if f == prefix+"Zipcode" {
			patchee.Zipcode = patcher.Zipcode
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Longitude" {
			patchee.Longitude = patcher.Longitude
			continue
		}
		if f == prefix+"Lattitude" {
			patchee.Lattitude = patcher.Lattitude
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AddressORM) error
}

// DefaultCreateTags executes a basic gorm create call
func DefaultCreateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TagsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TagsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TagsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTags(ctx context.Context, in *Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TagsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTagsSet(ctx context.Context, in []*Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TagsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Tags, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Tags, *gorm.DB) error
}

// DefaultStrictUpdateTags clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTags")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TagsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TagsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTags executes a basic gorm update call with patch behavior
func DefaultPatchTags(ctx context.Context, in *Tags, updateMask *field_mask.FieldMask, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Tags
	var err error
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTags(ctx, &Tags{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTags(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTags(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TagsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TagsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTags executes a bulk gorm update call with patch behavior
func DefaultPatchSetTags(ctx context.Context, objects []*Tags, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Tags, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Tags, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTags(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTags patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTags(ctx context.Context, patchee *Tags, patcher *Tags, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Tags, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TagName" {
			patchee.TagName = patcher.TagName
			continue
		}
		if f == prefix+"TagDescription" {
			patchee.TagDescription = patcher.TagDescription
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTags executes a gorm list call
func DefaultListTags(ctx context.Context, db *gorm.DB) ([]*Tags, error) {
	in := Tags{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TagsORM{}, &Tags{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TagsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tags{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TagsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TagsORM) error
}

// DefaultCreateRole executes a basic gorm create call
func DefaultCreateRole(ctx context.Context, in *Role, db *gorm.DB) (*Role, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type RoleORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadRole(ctx context.Context, in *Role, db *gorm.DB) (*Role, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &RoleORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := RoleORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(RoleORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type RoleORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteRole(ctx context.Context, in *Role, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&RoleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type RoleORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteRoleSet(ctx context.Context, in []*Role, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&RoleORM{})).(RoleORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&RoleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&RoleORM{})).(RoleORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type RoleORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Role, *gorm.DB) (*gorm.DB, error)
}
type RoleORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Role, *gorm.DB) error
}

// DefaultStrictUpdateRole clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateRole(ctx context.Context, in *Role, db *gorm.DB) (*Role, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateRole")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &RoleORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(RoleORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAuditLog := RoleAuditEventsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAuditLog.RoleId = new(int64)
	*filterAuditLog.RoleId = ormObj.Id
	if err = db.Where(filterAuditLog).Delete(RoleAuditEventsORM{}).Error; err != nil {
		return nil, err
	}
	filterBusiness := BusinessAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBusiness.RoleId = new(int64)
	*filterBusiness.RoleId = ormObj.Id
	if err = db.Where(filterBusiness).Delete(BusinessAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterTeam := TeamORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTeam.RoleId = new(int64)
	*filterTeam.RoleId = ormObj.Id
	if err = db.Where(filterTeam).Delete(TeamORM{}).Error; err != nil {
		return nil, err
	}
	filterUser := UserAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterUser.RoleId = new(int64)
	*filterUser.RoleId = ormObj.Id
	if err = db.Where(filterUser).Delete(UserAccountORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type RoleORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchRole executes a basic gorm update call with patch behavior
func DefaultPatchRole(ctx context.Context, in *Role, updateMask *field_mask.FieldMask, db *gorm.DB) (*Role, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Role
	var err error
	if hook, ok := interface{}(&pbObj).(RoleWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadRole(ctx, &Role{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(RoleWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskRole(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(RoleWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateRole(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(RoleWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type RoleWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Role, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RoleWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Role, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RoleWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Role, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RoleWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Role, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetRole executes a bulk gorm update call with patch behavior
func DefaultPatchSetRole(ctx context.Context, objects []*Role, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Role, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Role, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchRole(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskRole patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskRole(ctx context.Context, patchee *Role, patcher *Role, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Role, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedTeam bool
	var updatedUser bool
	var updatedBusiness bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"CanCreateUsers" {
			patchee.CanCreateUsers = patcher.CanCreateUsers
			continue
		}
		if f == prefix+"CanReadUsers" {
			patchee.CanReadUsers = patcher.CanReadUsers
			continue
		}
		if f == prefix+"CanUpdateUsers" {
			patchee.CanUpdateUsers = patcher.CanUpdateUsers
			continue
		}
		if f == prefix+"CanDeleteUsers" {
			patchee.CanDeleteUsers = patcher.CanDeleteUsers
			continue
		}
		if f == prefix+"CanCreateProjects" {
			patchee.CanCreateProjects = patcher.CanCreateProjects
			continue
		}
		if f == prefix+"CanReadProjects" {
			patchee.CanReadProjects = patcher.CanReadProjects
			continue
		}
		if f == prefix+"CanUpdateProjects" {
			patchee.CanUpdateProjects = patcher.CanUpdateProjects
			continue
		}
		if f == prefix+"CanDeleteProjects" {
			patchee.CanDeleteProjects = patcher.CanDeleteProjects
			continue
		}
		if f == prefix+"CanCreateReports" {
			patchee.CanCreateReports = patcher.CanCreateReports
			continue
		}
		if f == prefix+"CanReadReports" {
			patchee.CanReadReports = patcher.CanReadReports
			continue
		}
		if f == prefix+"CanUpdateReports" {
			patchee.CanUpdateReports = patcher.CanUpdateReports
			continue
		}
		if f == prefix+"CanDeleteReports" {
			patchee.CanDeleteReports = patcher.CanDeleteReports
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"AuditLog" {
			patchee.AuditLog = patcher.AuditLog
			continue
		}
		if !updatedTeam && strings.HasPrefix(f, prefix+"Team.") {
			updatedTeam = true
			if patcher.Team == nil {
				patchee.Team = nil
				continue
			}
			if patchee.Team == nil {
				patchee.Team = &Team{}
			}
			if o, err := DefaultApplyFieldMaskTeam(ctx, patchee.Team, patcher.Team, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Team.", db); err != nil {
				return nil, err
			} else {
				patchee.Team = o
			}
			continue
		}
		if f == prefix+"Team" {
			updatedTeam = true
			patchee.Team = patcher.Team
			continue
		}
		if !updatedUser && strings.HasPrefix(f, prefix+"User.") {
			updatedUser = true
			if patcher.User == nil {
				patchee.User = nil
				continue
			}
			if patchee.User == nil {
				patchee.User = &UserAccount{}
			}
			if o, err := DefaultApplyFieldMaskUserAccount(ctx, patchee.User, patcher.User, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"User.", db); err != nil {
				return nil, err
			} else {
				patchee.User = o
			}
			continue
		}
		if f == prefix+"User" {
			updatedUser = true
			patchee.User = patcher.User
			continue
		}
		if !updatedBusiness && strings.HasPrefix(f, prefix+"Business.") {
			updatedBusiness = true
			if patcher.Business == nil {
				patchee.Business = nil
				continue
			}
			if patchee.Business == nil {
				patchee.Business = &BusinessAccount{}
			}
			if o, err := DefaultApplyFieldMaskBusinessAccount(ctx, patchee.Business, patcher.Business, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Business.", db); err != nil {
				return nil, err
			} else {
				patchee.Business = o
			}
			continue
		}
		if f == prefix+"Business" {
			updatedBusiness = true
			patchee.Business = patcher.Business
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListRole executes a gorm list call
func DefaultListRole(ctx context.Context, db *gorm.DB) ([]*Role, error) {
	in := Role{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &RoleORM{}, &Role{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []RoleORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Role{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type RoleORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]RoleORM) error
}

// DefaultCreateRoleAuditEvents executes a basic gorm create call
func DefaultCreateRoleAuditEvents(ctx context.Context, in *RoleAuditEvents, db *gorm.DB) (*RoleAuditEvents, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type RoleAuditEventsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadRoleAuditEvents(ctx context.Context, in *RoleAuditEvents, db *gorm.DB) (*RoleAuditEvents, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &RoleAuditEventsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := RoleAuditEventsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(RoleAuditEventsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type RoleAuditEventsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteRoleAuditEvents(ctx context.Context, in *RoleAuditEvents, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&RoleAuditEventsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type RoleAuditEventsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteRoleAuditEventsSet(ctx context.Context, in []*RoleAuditEvents, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&RoleAuditEventsORM{})).(RoleAuditEventsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&RoleAuditEventsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&RoleAuditEventsORM{})).(RoleAuditEventsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type RoleAuditEventsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*RoleAuditEvents, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*RoleAuditEvents, *gorm.DB) error
}

// DefaultStrictUpdateRoleAuditEvents clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateRoleAuditEvents(ctx context.Context, in *RoleAuditEvents, db *gorm.DB) (*RoleAuditEvents, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateRoleAuditEvents")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &RoleAuditEventsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type RoleAuditEventsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchRoleAuditEvents executes a basic gorm update call with patch behavior
func DefaultPatchRoleAuditEvents(ctx context.Context, in *RoleAuditEvents, updateMask *field_mask.FieldMask, db *gorm.DB) (*RoleAuditEvents, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj RoleAuditEvents
	var err error
	if hook, ok := interface{}(&pbObj).(RoleAuditEventsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadRoleAuditEvents(ctx, &RoleAuditEvents{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(RoleAuditEventsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskRoleAuditEvents(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(RoleAuditEventsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateRoleAuditEvents(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(RoleAuditEventsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type RoleAuditEventsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *RoleAuditEvents, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *RoleAuditEvents, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *RoleAuditEvents, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *RoleAuditEvents, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetRoleAuditEvents executes a bulk gorm update call with patch behavior
func DefaultPatchSetRoleAuditEvents(ctx context.Context, objects []*RoleAuditEvents, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*RoleAuditEvents, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*RoleAuditEvents, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchRoleAuditEvents(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskRoleAuditEvents patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskRoleAuditEvents(ctx context.Context, patchee *RoleAuditEvents, patcher *RoleAuditEvents, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*RoleAuditEvents, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTimestamp bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Action" {
			patchee.Action = patcher.Action
			continue
		}
		if f == prefix+"PerformedBy" {
			patchee.PerformedBy = patcher.PerformedBy
			continue
		}
		if !updatedTimestamp && strings.HasPrefix(f, prefix+"Timestamp.") {
			if patcher.Timestamp == nil {
				patchee.Timestamp = nil
				continue
			}
			if patchee.Timestamp == nil {
				patchee.Timestamp = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Timestamp."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Timestamp, patchee.Timestamp, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Timestamp" {
			updatedTimestamp = true
			patchee.Timestamp = patcher.Timestamp
			continue
		}
		if f == prefix+"AffectedFields" {
			patchee.AffectedFields = patcher.AffectedFields
			continue
		}
		if f == prefix+"PreviousValues" {
			patchee.PreviousValues = patcher.PreviousValues
			continue
		}
		if f == prefix+"ClientIp" {
			patchee.ClientIp = patcher.ClientIp
			continue
		}
		if f == prefix+"UserAgent" {
			patchee.UserAgent = patcher.UserAgent
			continue
		}
		if f == prefix+"Context" {
			patchee.Context = patcher.Context
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListRoleAuditEvents executes a gorm list call
func DefaultListRoleAuditEvents(ctx context.Context, db *gorm.DB) ([]*RoleAuditEvents, error) {
	in := RoleAuditEvents{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &RoleAuditEventsORM{}, &RoleAuditEvents{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []RoleAuditEventsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RoleAuditEventsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*RoleAuditEvents{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type RoleAuditEventsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type RoleAuditEventsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]RoleAuditEventsORM) error
}
